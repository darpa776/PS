#include <iostream>
using namespace std;
int dp[101][101][101];

static long rook(int x,int y, int k) {
    //예외처리
    if (x < 0 || y < 0 || k < 0) {
        return 0;
    }
    // 룩을 모두 놓았으니 재귀 시작
    if (k == 0) {
        return 1;
    }

    // 이미 계산해놓았다면 결과사용
    if (dp[x][y][k] != -1) {
        return dp[x][y][k];
    }

    // 모든 경우의 수를 담을 변수
    long long ans = 0;
    
    //1. 룩을 아예 놓지 않을 경우
    //현재 x에서 어떤 행에도 룩을 놓지 않는다.
    ans += rook(x-1, y, k);
    //2. 겹치지 않도록 룩을 놓을 경우
    //현재 x에서 y개의 행중에 한 군데에 룩을 놓는다.
    //다음 재귀함수는 현재 x,y 를 제외한 위치에 k-1개의 룩을 놓아야한다.
    ans += rook(x-1, y - 1, k - 1) * y;
    //3. 두개의 룩을 놓는데, 같은 열에(같은 세로에) 놓는 경우
    //세로방향으로 아무곳이나 두곳에 룩을 놓는다. yC2
    //다음 재귀함수는 현재 룩을 놓은 x를 제외한 위치, y에 놓은 2개를 제외한 위치에 k-2개의 룩을 놓아야한다.
    ans += rook(x-1, y - 2, k - 2) * y * (y - 1) / 2;
    //4. 두개의 룩을 놓는데, 같은 행에(같은 가로에) 놓는 경우
    //가로방향으로 아무곳이나 두곳에 룩을 놓는다.
    //첫번째 룩은 현재 x 위치의 y개 행중 한 곳에 놓는다.(경우의 수: y)
    //두번째 룩은 놓여진 룩의 같은 행 중 이미 놓인 곳을 제외한 곳에 놓는다.(경우의 수: x-1)
    //다음 재귀함수는 x에 놓은 2개를 제외한 위치, y-1개의 위치에 k-2개의 룩을 놓아야한다.
    ans += rook(x - 2, y - 1, k - 2) * y * (x-1);

    // 결과를 문제조건에 맞게 바꾸고 저장 및 반환
    ans %= 1000001;
    dp[x][y][k] = ans;
    return ans;

}

int main() {

	int n, m, k;
	cin >> n >> m >> k;
	
    //메모테이블 초기화
    for (int i = 0; i < 101; i++) {
        for (int j = 0; j < 101; j++) {
                fill_n(dp[i][j],101, -1);
        }
    }
    
    //가로로 진행한다. x가 증가하는 방향
    cout << rook(n,m,k) << endl;

	return 0;
}
